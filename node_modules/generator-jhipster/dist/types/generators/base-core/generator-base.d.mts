import type { CopyOptions } from 'mem-fs-editor';
import type { Data as TemplateData, Options as TemplateOptions } from 'ejs';
import YeomanGenerator, { type ComposeOptions, type Storage } from 'yeoman-generator';
import SharedData from '../base/shared-data.mjs';
import { Logger } from '../base/support/index.mjs';
import type { JHipsterGeneratorOptions, JHipsterGeneratorFeatures, EditFileCallback, EditFileOptions, CascatedEditFileCallback, JHipsterOptions, ValidationResult, WriteFileOptions, JHipsterArguments } from '../base/api.mjs';
import { CommonClientServerApplication } from '../base-application/types.mjs';
import NeedleApi from '../needle-api.mjs';
/**
 * This is the base class for a generator for every generator.
 */
export default class CoreGenerator extends YeomanGenerator<JHipsterGeneratorOptions, JHipsterGeneratorFeatures> {
    static asPriority: (priorityName: string) => string;
    static INITIALIZING: string;
    static PROMPTING: string;
    static CONFIGURING: string;
    static COMPOSING: string;
    static LOADING: string;
    static PREPARING: string;
    static DEFAULT: string;
    static WRITING: string;
    static POST_WRITING: string;
    static INSTALL: string;
    static POST_INSTALL: string;
    static END: string;
    useVersionPlaceholders?: boolean;
    skipChecks?: boolean;
    experimental?: boolean;
    debugEnabled?: boolean;
    jhipster7Migration?: boolean;
    readonly sharedData: SharedData<CommonClientServerApplication>;
    readonly logger: Logger;
    jhipsterConfig: Record<string, any>;
    /**
     * @deprecated
     */
    configOptions: Record<string, any>;
    jhipsterTemplatesFolders: string[];
    blueprintStorage?: Storage;
    private _jhipsterGenerator?;
    private _needleApi?;
    env: any;
    log: Logger;
    constructor(args: string | string[], options: JHipsterGeneratorOptions, features: JHipsterGeneratorFeatures);
    /**
     * Override yeoman generator's usage function to fine tune --help message.
     */
    usage(): string;
    /**
     * @deprecated
     */
    get needleApi(): NeedleApi;
    /**
     * Check if the JHipster version used to generate an existing project is less than the passed version argument
     *
     * @param {string} version - A valid semver version string
     */
    isJhipsterVersionLessThan(version: any): boolean;
    /**
     * Get arguments for the priority
     */
    getArgsForPriority(priorityName: string): {
        control: import("../base/types.mjs").Control;
        source: any;
    }[] | {
        control: import("../base/types.mjs").Control;
    }[];
    /**
     * Override yeoman-generator method that gets methods to be queued, filtering the result.
     */
    getTaskNames(): string[];
    /**
     * Load options from an object.
     * When composing, we need to load options from others generators, externalising options allow to easily load them.
     * @param options - Object containing options.
     * @param common - skip generator scoped options.
     */
    parseJHipsterOptions(options: JHipsterOptions, common?: boolean): void;
    parseJHipsterArguments(jhipsterArguments?: JHipsterArguments): void;
    /**
     * Alternative templatePath that fetches from the blueprinted generator, instead of the blueprint.
     */
    jhipsterTemplatePath(...path: string[]): string;
    /**
     * Compose with a jhipster generator using default jhipster config.
     * @return {object} the composed generator
     */
    composeWithJHipster(generator: string, options?: ComposeOptions): Promise<import("@yeoman/types").BaseGenerator[]>;
    /**
     * Compose with a jhipster generator using default jhipster config, but queue it immediately.
     */
    dependsOnJHipster(generator: string, options?: ComposeOptions): Promise<import("@yeoman/types").BaseGenerator[]>;
    /**
     * Remove File
     * @param file
     */
    removeFile(...path: string[]): string;
    /**
     * Remove Folder
     * @param path
     */
    removeFolder(...path: string[]): void;
    /**
     * Fetch files from the generator-jhipster instance installed
     */
    fetchFromInstalledJHipster(...path: string[]): string;
    /**
     * Utility function to write file.
     *
     * @param source
     * @param destination - destination
     * @param data - template data
     * @param options - options passed to ejs render
     * @param copyOptions
     */
    writeFile(source: string, destination: string, data?: TemplateData, options?: TemplateOptions, copyOptions?: CopyOptions): void;
    /**
     * write the given files using provided options.
     */
    writeFiles<DataType = any>(options: WriteFileOptions<this, DataType>): Promise<string[]>;
    /**
     * Edit file content.
     * Edits an empty file if `options.create` is truthy or no callback is passed.
     * @example
     * // Throws if `foo.txt` doesn't exists or append the content.
     * editFile('foo.txt', content => content + 'foo.txt content');
     * @example
     * // Appends `foo.txt` content if whether exists or not.
     * editFile('foo.txt', { create: true }, content => content + 'foo.txt content');
     * @example
     * // Appends `foo.txt` content if whether exists or not using the returned cascaded callback.
     * editFile('foo.txt')(content => content + 'foo.txt content');
     */
    editFile(file: string, ...transformCallbacks: EditFileCallback<this>[]): CascatedEditFileCallback<this>;
    editFile(file: string, options: EditFileOptions, ...transformCallbacks: EditFileCallback<this>[]): CascatedEditFileCallback<this>;
    /**
     * Convert value to a yaml and write to destination
     */
    writeDestinationYaml(filepath: string, value: Record<string | number, any>): void;
    /**
     * Merge value to an existing yaml and write to destination
     * Removes every comment (due to parsing/merging process) except the at the top of the file.
     */
    mergeDestinationYaml(filepath: string, value: Record<string | number, any>): void;
    /**
     * Shallow clone or convert dependencies to placeholder if needed.
     */
    prepareDependencies(map: Record<string, string>, valuePlaceholder?: (value: string) => string): Record<string, string>;
    loadNodeDependencies(destination: Record<string, string>, source: Record<string, string>): void;
    loadNodeDependenciesFromPackageJson(destination: Record<string, string>, packageJsonFile: string): void;
    /**
     * Print ValidationResult info/warnings or throw result Error.
     */
    validateResult(result: ValidationResult, { throwOnError }?: {
        throwOnError?: boolean | undefined;
    }): void;
    /**
     * Checks if there is a newer JHipster version available.
     */
    protected checkForNewVersion(): Promise<void>;
    /**
     * Create a simple-git instance using current destinationPath as baseDir.
     */
    createGit(): import("simple-git").SimpleGit;
    private createSharedData;
}
